<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ultimate 1v1 Tag Arena</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body {
            height: 100%;
        }
        body {
            background: #181f2a;
            color: #efefef;
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        h1, h2 {
            text-align: center;
            margin: 0.8em 0;
            font-weight: 700;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        #menu, #game, #endScreen {
            max-width: 520px;
            margin: 2em auto;
            background: #24304a;
            border-radius: 16px;
            box-shadow: 0 5px 20px #0008;
            padding: 2em;
            z-index: 2;
        }
        #menu button, #endScreen button, #fullscreenBtn {
            display: block;
            width: 100%;
            margin: 1em 0;
            padding: 0.9em;
            font-size: 1.2em;
            border: none;
            border-radius: 8px;
            background: #ffb300;
            color: #181f2a;
            cursor: pointer;
            font-weight: bold;
        }
        #menu button:hover, #endScreen button:hover, #fullscreenBtn:hover {
            background: #ffa000;
        }
        #settings {
            margin-bottom: 1.5em;
        }
        #settings label {
            margin-bottom: 0.7em;
            display: block;
        }
        #game {
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 2;
        }
        #players {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 1em;
        }
        .playerCard {
            flex: 1;
            background: #2f3c58;
            border-radius: 8px;
            margin: 0 0.5em;
            padding: 1em;
            text-align: center;
            box-shadow: 0 2px 8px #0004;
        }
        .active {
            border: 2px solid #ffb300;
        }
        #arenaWrapper {
            position: relative;
            width: 90vw;
            max-width: 900px;
            height: 60vw;
            max-height: 600px;
            background: none;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 1em auto;
        }
        #arena {
            position: relative;
            width: 600px;
            height: 600px;
            background: #202b3c;
            border: 2px solid #ffb300;
            border-radius: 16px;
            overflow: hidden;
            transition: width 0.2s, height 0.2s;
        }
        .player {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            font-weight: bold;
        }
        .player.p1 { background: #42a5f5; color: #fff; border: 2px solid #1976d2; }
        .player.p2 { background: #e53935; color: #fff; border: 2px solid #b71c1c; }
        .player.it { box-shadow: 0 0 12px 4px #ffb30088; }
        .player.stunned { filter: grayscale(1) brightness(0.6); }
        .obstacle {
            position: absolute;
            background: #374963;
            border-radius: 10px;
            border: 2px solid #7986cb;
        }
        #actions {
            display: flex;
            justify-content: center;
            margin: 1em 0;
        }
        #actions button {
            margin: 0 0.5em;
            padding: 0.7em 1.2em;
            font-size: 1em;
            border-radius: 7px;
            background: #37474f;
            color: white;
            border: none;
            cursor: pointer;
        }
        #actions button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #log {
            background: #222b;
            color: #fffde7;
            padding: 1em;
            border-radius: 6px;
            height: 110px;
            overflow-y: auto;
            font-size: 0.97em;
            margin-top: 1em;
            font-family: 'Consolas', monospace;
        }
        #endScreen {
            display: none;
            text-align: center;
        }
        #endScreen h2 { color: #ffb300; }
        #timer {
            font-size: 1.15em;
            color: #ffb300;
            font-weight: bold;
            text-align: center;
            margin-bottom: 8px;
        }
        #rules {
            display: none;
            background: #232c3b;
            color: #fff;
            border-radius: 8px;
            padding: 1em;
            margin-top: 1em;
        }
        #keyHint {
            text-align:center;
            color:#b3e5fc;
            font-size:1em;
            margin-bottom: 0.7em;
        }
        #fullscreenBtn {
            width: 98%;
            margin: 1em auto 0 auto;
        }
        @media (max-width: 700px) {
            #arenaWrapper { width: 98vw; height: 98vw; max-width: 98vw; max-height: 98vw;}
            #arena { width: 98vw; height: 98vw; max-width: 98vw; max-height: 98vw;}
        }
    </style>
</head>
<body>
<div id="container">
    <h1>Ultimate 1v1 Tag Arena</h1>
    <div id="menu">
        <div id="settings">
            <label>
                Player 1 Name:
                <input type="text" id="p1name" value="Player 1" maxlength="12">
            </label>
            <label>
                Player 2 Name:
                <input type="text" id="p2name" value="Player 2" maxlength="12">
            </label>
            <label>
                <input type="checkbox" id="vsAI" checked>
                Play vs Computer
            </label>
            <label>
                <input type="checkbox" id="hardAI">
                Hard AI
            </label>
            <label>
                Game Time (seconds):
                <input type="number" id="gameTime" value="90" min="30" max="300" style="width:60px;">
            </label>
            <label>
                Obstacles:
                <input type="number" id="obstacleCount" value="5" min="0" max="20" style="width:40px;">
            </label>
        </div>
        <button id="startBtn">Start Game</button>
        <button onclick="showRules()">How to Play</button>
        <button id="fullscreenBtn">Fullscreen Mode</button>
        <div id="rules">
            <h2>Tag Arena - Rules</h2>
            <ul>
                <li>Players move around the arena, trying to tag each other.</li>
                <li>One player starts as "It". If "It" touches the other, roles swap.</li>
                <li>Every second as "It" earns you points.</li>
                <li>Obstacles block movement; use them for strategy!</li>
                <li>Play with keyboard: P1 uses Arrow keys, P2 uses WASD.</li>
                <li>In 1v1: both players control with keyboard. Vs Computer: AI controls P2.</li>
                <li>After tagging, the tagged player is stunned briefly.</li>
                <li>Game ends when time runs out. Player with most points wins!</li>
            </ul>
        </div>
    </div>
    <div id="game">
        <div id="timer"></div>
        <div id="keyHint"></div>
        <div id="players">
            <div class="playerCard" id="player1Card">
                <h2 id="p1Display">Player 1</h2>
                <div>Score: <span id="p1Score">0</span></div>
                <div>Times Tagged: <span id="p1Tagged">0</span></div>
            </div>
            <div class="playerCard" id="player2Card">
                <h2 id="p2Display">Player 2</h2>
                <div>Score: <span id="p2Score">0</span></div>
                <div>Times Tagged: <span id="p2Tagged">0</span></div>
            </div>
        </div>
        <div id="arenaWrapper">
            <div id="arena"></div>
        </div>
        <div id="actions">
            <button id="pauseBtn">Pause</button>
        </div>
        <div id="log"></div>
    </div>
    <div id="endScreen">
        <h2 id="winnerText"></h2>
        <div id="endStats"></div>
        <button onclick="restartGame()">Play Again</button>
        <button onclick="backToMenu()">Main Menu</button>
    </div>
</div>
<script>
    // Constants
    let ARENA_SIZE = 600;
    const PLAYER_SIZE = 36;
    const PLAYER_SPEED = 4.6;
    const STUN_TIME = 1100;
    const TAG_RADIUS = 38;
    const OBSTACLE_MIN_SIZE = 42;
    const OBSTACLE_MAX_SIZE = 88;
    const SCORE_PER_SEC = 1;
    const LOG_LIMIT = 16;
    const OBSTACLE_MARGIN = 62; // used to ensure a path exists

    // State
    let gameState = null;
    let timerInterval = null;
    let aiInterval = null;
    let isPaused = false;

    // DOM
    const menu = document.getElementById('menu');
    const game = document.getElementById('game');
    const arena = document.getElementById('arena');
    const arenaWrapper = document.getElementById('arenaWrapper');
    const timerDiv = document.getElementById('timer');
    const keyHint = document.getElementById('keyHint');
    const p1nameInput = document.getElementById('p1name');
    const p2nameInput = document.getElementById('p2name');
    const vsAIInput = document.getElementById('vsAI');
    const hardAIInput = document.getElementById('hardAI');
    const gameTimeInput = document.getElementById('gameTime');
    const obstacleCountInput = document.getElementById('obstacleCount');
    const player1Card = document.getElementById('player1Card');
    const player2Card = document.getElementById('player2Card');
    const p1Display = document.getElementById('p1Display');
    const p2Display = document.getElementById('p2Display');
    const p1Score = document.getElementById('p1Score');
    const p2Score = document.getElementById('p2Score');
    const p1Tagged = document.getElementById('p1Tagged');
    const p2Tagged = document.getElementById('p2Tagged');
    const logDiv = document.getElementById('log');
    const endScreen = document.getElementById('endScreen');
    const winnerText = document.getElementById('winnerText');
    const endStats = document.getElementById('endStats');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    // Show/hide rules
    function showRules() {
        const rules = document.getElementById('rules');
        rules.style.display = rules.style.display === 'none' ? 'block' : 'none';
    }

    // Fullscreen button logic
    fullscreenBtn.onclick = () => {
        fullScreenArena();
    };

    function fullScreenArena() {
        const container = document.getElementById('container');
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
            container.mozRequestFullScreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        }
        // Resize ARENA_SIZE to fit window
        setTimeout(() => {
            const w = window.innerWidth, h = window.innerHeight;
            const size = Math.min(w, h, 900, 600);
            ARENA_SIZE = size;
            arena.style.width = size + 'px';
            arena.style.height = size + 'px';
            arenaWrapper.style.width = size + 'px';
            arenaWrapper.style.height = size + 'px';
            if (gameState) renderGame();
        }, 200);
    }

    // Exit fullscreen restore arena size
    document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement) {
            ARENA_SIZE = 600;
            arena.style.width = ARENA_SIZE + 'px';
            arena.style.height = ARENA_SIZE + 'px';
            arenaWrapper.style.width = ARENA_SIZE + 'px';
            arenaWrapper.style.height = ARENA_SIZE + 'px';
            if (gameState) renderGame();
        }
    });

    // Start game
    startBtn.onclick = () => {
        startGame();
    };

    function startGame() {
        ARENA_SIZE = 600;
        arena.style.width = ARENA_SIZE + 'px';
        arena.style.height = ARENA_SIZE + 'px';
        arenaWrapper.style.width = ARENA_SIZE + 'px';
        arenaWrapper.style.height = ARENA_SIZE + 'px';

        // Get settings
        const p1name = p1nameInput.value.trim() || "Player 1";
        const p2name = p2nameInput.value.trim() || (vsAIInput.checked ? "Computer" : "Player 2");
        const vsAI = vsAIInput.checked;
        const hardAI = hardAIInput.checked;
        const gameSeconds = Math.max(30, Math.min(300, Number(gameTimeInput.value))) || 90;
        const obstacleCount = Math.max(0, Math.min(20, Number(obstacleCountInput.value))) || 5;

        // Initial positions (far corners)
        let p1pos = { x: 32, y: 32 };
        let p2pos = { x: ARENA_SIZE-PLAYER_SIZE-32, y: ARENA_SIZE-PLAYER_SIZE-32 };

        // Obstacles - new algorithm: ensure a central path always exists!
        let obstacles = [];
        let attempts = 0;
        while (obstacles.length < obstacleCount && attempts < 120) {
            attempts++;
            let ow = Math.floor(Math.random()*(OBSTACLE_MAX_SIZE-OBSTACLE_MIN_SIZE))+OBSTACLE_MIN_SIZE;
            let oh = Math.floor(Math.random()*(OBSTACLE_MAX_SIZE-OBSTACLE_MIN_SIZE))+OBSTACLE_MIN_SIZE;
            let ox = Math.random()*(ARENA_SIZE-ow-8)+4;
            let oy = Math.random()*(ARENA_SIZE-oh-8)+4;

            // Don't block spawn
            let distToP1 = Math.hypot(p1pos.x-ox, p1pos.y-oy);
            let distToP2 = Math.hypot(p2pos.x-ox, p2pos.y-oy);
            let valid = distToP1 > OBSTACLE_MARGIN && distToP2 > OBSTACLE_MARGIN;

            // Don't overlap other obstacles
            for (const o of obstacles) {
                if (ox+ow > o.x && ox < o.x+o.w && oy+oh > o.y && oy < o.y+o.h) valid = false;
            }
            // Don't block central vertical/horizontal corridor (guaranteed path)
            let cx1 = ARENA_SIZE/2 - 70, cx2 = ARENA_SIZE/2 + 70;
            let cy1 = ARENA_SIZE/2 - 70, cy2 = ARENA_SIZE/2 + 70;
            if ((ox < cx2 && ox+ow > cx1) && (oy < ARENA_SIZE && oy+oh > 0)) valid = false;
            if ((oy < cy2 && oy+oh > cy1) && (ox < ARENA_SIZE && ox+ow > 0)) valid = false;

            if (valid) obstacles.push({ x: ox, y: oy, w: ow, h: oh });
        }

        // Game state
        gameState = {
            players: [
                { name: p1name, symbol: 'p1', pos: {...p1pos}, dir: {x:0, y:0}, score: 0, tagged: 0, isAI: false, stun: 0, isIt: false },
                { name: p2name, symbol: 'p2', pos: {...p2pos}, dir: {x:0, y:0}, score: 0, tagged: 0, isAI: vsAI, aiLevel: hardAI?'hard':'easy', stun: 0, isIt: false }
            ],
            obstacles,
            gameSeconds,
            timeLeft: gameSeconds,
            log: [],
            running: true,
            paused: false,
            lastIt: Math.random()<0.5?0:1,
            tick: 0
        };
        gameState.players[gameState.lastIt].isIt = true;

        // UI setup
        menu.style.display = 'none';
        game.style.display = 'flex';
        endScreen.style.display = 'none';
        isPaused = false;
        logMsg(`Game started! ${p1name} vs ${p2name}`);
        logMsg(`${gameState.players[gameState.lastIt].name} is "It" first!`);
        keyHint.innerHTML = vsAI ? 
            "You: Arrow keys<br>Computer moves automatically." : 
            "P1: Arrow keys &nbsp;|&nbsp; P2: WASD";
        renderGame();
        focusArena();

        // Timer
        clearInterval(timerInterval);
        timerInterval = setInterval(gameTick, 40);

        // AI loop
        clearInterval(aiInterval);
        if (vsAI) {
            aiInterval = setInterval(aiMove, 50);
        }

        // Keyboard
        window.addEventListener('keydown', handleKeyDown, { passive: false });
        window.addEventListener('keyup', handleKeyUp, { passive: false });
        pauseBtn.onclick = togglePause;
        pauseBtn.textContent = "Pause";
    }

    function focusArena() {
        arena.tabIndex = 0;
        arena.focus();
    }

    function restartGame() {
        clearInterval(timerInterval);
        clearInterval(aiInterval);
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
        menu.style.display = 'block';
        game.style.display = 'none';
        endScreen.style.display = 'none';
        arena.innerHTML = '';
        logDiv.innerHTML = '';
    }

    function backToMenu() {
        restartGame();
    }

    // Rendering
    function renderGame() {
        // Players
        p1Display.textContent = gameState.players[0].name;
        p2Display.textContent = gameState.players[1].name;
        p1Score.textContent = gameState.players[0].score;
        p2Score.textContent = gameState.players[1].score;
        p1Tagged.textContent = gameState.players[0].tagged;
        p2Tagged.textContent = gameState.players[1].tagged;
        player1Card.classList.toggle('active', gameState.players[0].isIt);
        player2Card.classList.toggle('active', gameState.players[1].isIt);

        // Timer
        let min = Math.floor(gameState.timeLeft/60);
        let sec = Math.floor(gameState.timeLeft)%60;
        timerDiv.textContent = `Time Left: ${min}:${sec<10?'0':''}${sec}`;

        // Arena
        arena.innerHTML = '';
        // Obstacles
        gameState.obstacles.forEach((o,oid)=> {
            const ob = document.createElement('div');
            ob.className = 'obstacle';
            ob.style.left = `${o.x}px`;
            ob.style.top = `${o.y}px`;
            ob.style.width = `${o.w}px`;
            ob.style.height = `${o.h}px`;
            arena.appendChild(ob);
        });
        // Players
        gameState.players.forEach((p,idx)=>{
            let pl = document.createElement('div');
            pl.className = `player ${p.symbol} ${p.isIt?'it':''} ${p.stun>0?'stunned':''}`;
            pl.style.left = `${p.pos.x}px`;
            pl.style.top = `${p.pos.y}px`;
            pl.textContent = p.isIt ? "IT" : p.symbol.toUpperCase();
            arena.appendChild(pl);
        });
    }

    // Logging
    function logMsg(msg) {
        gameState.log.push(`[${Math.floor(gameState.gameSeconds-gameState.timeLeft+1)}s] ${msg}`);
        if (gameState.log.length > LOG_LIMIT) gameState.log.shift();
        logDiv.innerHTML = gameState.log.map(m=>`<div>${m}</div>`).join('');
    }

    // Game tick (main loop)
    function gameTick() {
        if (!gameState.running || gameState.paused) return;
        gameState.tick++;
        if (gameState.tick % 25 === 0 && gameState.timeLeft > 0) {
            // Score for "It"
            for (let pi=0; pi<2; ++pi) {
                if (gameState.players[pi].isIt) {
                    gameState.players[pi].score += SCORE_PER_SEC;
                }
            }
            gameState.timeLeft--;
            if (gameState.timeLeft <= 0) {
                endGame();
                return;
            }
        }

        // Move players
        movePlayers();

        // Check tag event
        checkTag();

        // Render
        renderGame();
    }

    // Move players
    function movePlayers() {
        for (let pi=0; pi<2; ++pi) {
            let p = gameState.players[pi];
            if (p.stun > 0) { p.stun -= 40; continue; }
            let dx = p.dir.x * PLAYER_SPEED, dy = p.dir.y * PLAYER_SPEED;
            if (dx === 0 && dy === 0) continue;
            let nx = p.pos.x + dx, ny = p.pos.y + dy;
            let bounds = {x:0, y:0, w:ARENA_SIZE-PLAYER_SIZE, h:ARENA_SIZE-PLAYER_SIZE};
            nx = Math.max(bounds.x, Math.min(bounds.w, nx));
            ny = Math.max(bounds.y, Math.min(bounds.h, ny));
            // Collide with obstacles
            let collided = false;
            for (const o of gameState.obstacles) {
                if (rectsOverlap(nx, ny, PLAYER_SIZE, PLAYER_SIZE, o.x, o.y, o.w, o.h)) {
                    collided = true;
                    break;
                }
            }
            if (!collided) {
                p.pos.x = nx;
                p.pos.y = ny;
            }
        }
    }

    function rectsOverlap(x1,y1,w1,h1,x2,y2,w2,h2) {
        return x1 < x2+w2 && x1+w1 > x2 && y1 < y2+h2 && y1+h1 > y2;
    }

    // Key handling
    function handleKeyDown(e) {
        if (!gameState.running || gameState.paused) return;
        let code = e.code;
        // Prevent Arrow keys from scrolling
        if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(code)) {
            e.preventDefault();
        }
        // Player 1: Arrow keys
        if (!gameState.players[0].isAI) {
            if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(code)) {
                switch(code){
                    case "ArrowUp": gameState.players[0].dir.y = -1; break;
                    case "ArrowDown": gameState.players[0].dir.y = 1; break;
                    case "ArrowLeft": gameState.players[0].dir.x = -1; break;
                    case "ArrowRight": gameState.players[0].dir.x = 1; break;
                }
            }
        }
        // Player 2: WASD
        if (!gameState.players[1].isAI) {
            if (["KeyW","KeyA","KeyS","KeyD"].includes(code)) {
                switch(code){
                    case "KeyW": gameState.players[1].dir.y = -1; break;
                    case "KeyS": gameState.players[1].dir.y = 1; break;
                    case "KeyA": gameState.players[1].dir.x = -1; break;
                    case "KeyD": gameState.players[1].dir.x = 1; break;
                }
            }
        }
    }
    function handleKeyUp(e) {
        let code = e.code;
        // Player 1
        if (!gameState.players[0].isAI) {
            if (["ArrowUp","ArrowDown"].includes(code)) gameState.players[0].dir.y = 0;
            if (["ArrowLeft","ArrowRight"].includes(code)) gameState.players[0].dir.x = 0;
        }
        // Player 2
        if (!gameState.players[1].isAI) {
            if (["KeyW","KeyS"].includes(code)) gameState.players[1].dir.y = 0;
            if (["KeyA","KeyD"].includes(code)) gameState.players[1].dir.x = 0;
        }
    }

    // AI logic
    function aiMove() {
        if (!gameState.running || gameState.paused) return;
        let ai = gameState.players[1];
        if (!ai.isAI || ai.stun > 0) { ai.dir.x = 0; ai.dir.y = 0; return; }
        let human = gameState.players[0];
        let target = ai.isIt ? human : ai;
        let avoid = ai.isIt ? ai : human;

        // Smart AI movement
        let dx=0,dy=0;
        // If "It", chase human
        if (ai.isIt) {
            let best = bestMoveToward(ai, human, gameState.obstacles, true, ai.aiLevel==='hard');
            dx = best.x;
            dy = best.y;
        } else {
            // Not "It", run away
            let best = bestMoveAway(ai, human, gameState.obstacles, ai.aiLevel==='hard');
            dx = best.x;
            dy = best.y;
        }
        ai.dir.x = dx;
        ai.dir.y = dy;
    }

    function bestMoveToward(ai, target, obstacles, allowDiagonal, hard) {
        let moves = [
            {x:-1,y:0}, {x:1,y:0}, {x:0,y:-1}, {x:0,y:1}
        ];
        if (allowDiagonal) moves.push({x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1});
        let best = {x:0,y:0};
        let minDist = 99999;
        for (let m of moves) {
            let nx = ai.pos.x + m.x*PLAYER_SPEED, ny = ai.pos.y + m.y*PLAYER_SPEED;
            let bounds = {x:0, y:0, w:ARENA_SIZE-PLAYER_SIZE, h:ARENA_SIZE-PLAYER_SIZE};
            nx = Math.max(bounds.x, Math.min(bounds.w, nx));
            ny = Math.max(bounds.y, Math.min(bounds.h, ny));
            let ok = true;
            for (const o of obstacles) {
                if (rectsOverlap(nx, ny, PLAYER_SIZE, PLAYER_SIZE, o.x, o.y, o.w, o.h)) ok = false;
            }
            if (!ok) continue;
            let d = Math.hypot(nx-target.pos.x, ny-target.pos.y);
            if (d < minDist) {
                minDist = d;
                best = m;
            }
        }
        // Hard AI tries to predict and cut off
        if (hard && Math.random()<0.35) {
            let hx = target.pos.x + target.dir.x*PLAYER_SPEED*2;
            let hy = target.pos.y + target.dir.y*PLAYER_SPEED*2;
            let mx = ai.pos.x, my = ai.pos.y;
            let dx = hx-mx, dy = hy-my;
            let dlen = Math.hypot(dx,dy);
            if (dlen>0) {
                best.x = Math.round(dx/dlen);
                best.y = Math.round(dy/dlen);
            }
        }
        return best;
    }

    function bestMoveAway(ai, chaser, obstacles, hard) {
        let moves = [
            {x:-1,y:0}, {x:1,y:0}, {x:0,y:-1}, {x:0,y:1},
            {x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}
        ];
        let best = {x:0,y:0};
        let maxDist = -1;
        for (let m of moves) {
            let nx = ai.pos.x + m.x*PLAYER_SPEED, ny = ai.pos.y + m.y*PLAYER_SPEED;
            let bounds = {x:0, y:0, w:ARENA_SIZE-PLAYER_SIZE, h:ARENA_SIZE-PLAYER_SIZE};
            nx = Math.max(bounds.x, Math.min(bounds.w, nx));
            ny = Math.max(bounds.y, Math.min(bounds.h, ny));
            let ok = true;
            for (const o of obstacles) {
                if (rectsOverlap(nx, ny, PLAYER_SIZE, PLAYER_SIZE, o.x, o.y, o.w, o.h)) ok = false;
            }
            if (!ok) continue;
            let d = Math.hypot(nx-chaser.pos.x, ny-chaser.pos.y);
            if (d > maxDist) {
                maxDist = d;
                best = m;
            }
        }
        // Hard AI: if stuck, try random or zig-zag
        if (hard && maxDist < 50 && Math.random()<0.6) {
            best = moves[Math.floor(Math.random()*moves.length)];
        }
        return best;
    }

    // Tag logic
    function checkTag() {
        let itIdx = gameState.players[0].isIt ? 0 : 1;
        let otherIdx = 1 - itIdx;
        let it = gameState.players[itIdx];
        let other = gameState.players[otherIdx];
        if (it.stun > 0 || other.stun > 0) return;
        let dist = Math.hypot(it.pos.x-other.pos.x, it.pos.y-other.pos.y);
        if (dist < TAG_RADIUS) {
            // Tag!
            it.isIt = false;
            other.isIt = true;
            other.tagged++;
            other.stun = STUN_TIME;
            logMsg(`${it.name} tagged ${other.name}!`);
            playTagSound();
        }
    }

    function playTagSound() {
        let ctx = new(window.AudioContext||window.webkitAudioContext)();
        let o = ctx.createOscillator();
        let g = ctx.createGain();
        o.type = 'square';
        o.frequency.value = 740;
        g.gain.value = 0.18;
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        o.frequency.linearRampToValueAtTime(380, ctx.currentTime+0.23);
        g.gain.linearRampToValueAtTime(0, ctx.currentTime+0.25);
        o.stop(ctx.currentTime+0.25);
    }

    // Pause
    function togglePause() {
        if (!gameState.running) return;
        gameState.paused = !gameState.paused;
        isPaused = gameState.paused;
        pauseBtn.textContent = isPaused ? "Resume" : "Pause";
        logMsg(isPaused ? "Game paused." : "Game resumed.");
    }

    // End game
    function endGame() {
        gameState.running = false;
        clearInterval(timerInterval);
        clearInterval(aiInterval);
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
        game.style.display = 'none';
        endScreen.style.display = 'block';

        let winner, winnerScore, loserScore;
        if (gameState.players[0].score > gameState.players[1].score) {
            winner = gameState.players[0].name;
            winnerScore = gameState.players[0].score;
            loserScore = gameState.players[1].score;
        } else if (gameState.players[1].score > gameState.players[0].score) {
            winner = gameState.players[1].name;
            winnerScore = gameState.players[1].score;
            loserScore = gameState.players[0].score;
        } else {
            winner = "Draw!";
            winnerScore = gameState.players[0].score;
            loserScore = gameState.players[1].score;
        }
        winnerText.innerHTML = `<span style="font-size:1.4em;">Winner:</span><br>${winner}`;
        endStats.innerHTML = `
            <div>
                <b>${gameState.players[0].name}:</b> ${gameState.players[0].score} pts, Tagged: ${gameState.players[0].tagged}<br>
                <b>${gameState.players[1].name}:</b> ${gameState.players[1].score} pts, Tagged: ${gameState.players[1].tagged}<br>
                <b>Total Time:</b> ${gameState.gameSeconds} seconds
            </div>
            <div style="margin-top:1em;">
                <b>Game Log:</b><br>
                <pre style="max-height:120px;overflow-y:auto;font-size:0.95em;">${gameState.log.join('\n')}</pre>
            </div>
            `;
    }

    // Resize for mobile/fullscreen
    function resizeArena() {
        let size = Math.min(window.innerWidth, window.innerHeight, 900);
        ARENA_SIZE = size < 400 ? 400 : size;
        arena.style.width = ARENA_SIZE + 'px';
        arena.style.height = ARENA_SIZE + 'px';
        arenaWrapper.style.width = ARENA_SIZE + 'px';
        arenaWrapper.style.height = ARENA_SIZE + 'px';
        if (gameState) renderGame();
    }
    window.addEventListener('resize', () => {
        resizeArena();
    });

</script>
</body>
</html>
